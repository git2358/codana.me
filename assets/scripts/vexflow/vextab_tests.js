// Generated by CoffeeScript 1.7.1

/*
VexTab Tests
Copyright Mohit Cheppudira 2010 <mohit@muthanna.com>
 */

(function() {
  var _base;

  if ((_base = Vex.Flow).Test == null) {
    _base.Test = {};
  }

  Vex.Flow.Test.VexTab = (function() {
    var catchError, makeParser, makeRenderer, renderTest;

    function VexTab() {}

    VexTab.Start = function() {
      module("VexTab Parser");
      test("Basic Test", this.basic);
      test("Complex Test", this.complex);
      test("Stave Options Test", this.staveOptionsTest);
      test("Notation Only Test", this.notationOnly);
      test("Tuning Test", this.tuning);
      test("String/Fret Test", this.stringFret);
      test("MultiFret Test", this.multiFret);
      test("Tie Test", this.tie);
      test("Bar Test", this.bar);
      test("Bend Test", this.bend);
      test("Vibrato Test", this.vibrato);
      test("Upstroke/Downstroke Test", this.strokes);
      test("Chord Test", this.chord);
      test("Tapping Test", this.tapping);
      test("Chord Ties Test", this.chordTies);
      test("Duration Test", this.duration);
      test("Triplets and Tuplets Test", this.tripletsAndTuplets);
      test("Dotted Notes Test", this.dottedNotes);
      test("Annotations Test", this.annotations);
      test("Long Bends Test", this.longBends);
      test("Rest Test", this.rest);
      test("Options Test", this.options);
      test("ABC Notes Test", this.abcNotes);
      test("ABC Notes with Frets Test", this.abcNotesWithFrets);
      test("Rhythm/Slash Notation Test", this.rhythmNotation);
      test("Text Lines", this.textLines);
      test("Sweep Strokes", this.sweepStrokes);
      test("Voices", this.voices);
      test("Fingering and String Numbers", this.fingering);
      test("Render", this.render);
      test("Render Complex", this.renderComplex);
      test("Tab Stems", this.tabStems);
      test("Rests in Tab", this.restsInTab);
      test("Multi String Tab", this.multiStringTab);
      test("Time Signature based Beaming", this.timeSigBeaming);
      test("Override Fret-Note", this.overrideFretNote);
      test("Mixed Tuplets", this.mixedTuplets);
      test("Accidental Strategies", this.accidentalStrategies);
      return test("Fret-hand Fingering and String Numbers", this.fingeringAndStrings);
    };

    catchError = function(tab, code, error_type) {
      var caught, e, error;
      if (error_type == null) {
        error_type = "ParseError";
      }
      error = {
        code: "NoError",
        message: "Expected exception not caught"
      };
      caught = false;
      try {
        tab.parse(code);
      } catch (_error) {
        e = _error;
        error = e;
        caught = true;
      }
      return equal(true, caught);
    };

    makeParser = function() {
      return new Vex.Flow.VexTab(new Vex.Flow.Artist(0, 0, 600, {
        scale: 0.8
      }));
    };

    makeRenderer = function(test_name) {
      var canvas, renderer, test_div;
      test_div = $('<div></div>').addClass("testcanvas");
      test_div.append($('<div></div>').addClass("name").text(test_name));
      canvas = $('<canvas></canvas>').addClass("vex-tabdiv");
      test_div.append(canvas);
      $("body").append(test_div);
      renderer = new Vex.Flow.Renderer(canvas[0], Vex.Flow.Renderer.Backends.CANVAS);
      return renderer;
    };

    renderTest = function(title, code) {
      var renderer, tab;
      tab = makeParser();
      renderer = makeRenderer(title);
      notEqual(null, tab.parse(code));
      tab.getArtist().render(renderer);
      return ok(true, "all pass");
    };

    VexTab.basic = function() {
      var tab;
      expect(3);
      tab = makeParser();
      notEqual(null, tab.parse("tabstave\n"));
      catchError(tab, "tabstave\n notes /2 10/3");
      return ok(true, "all pass");
    };

    VexTab.complex = function() {
      var code, tab;
      expect(2);
      tab = makeParser();
      code = "tabstave notation=true key=A\nnotes :q (5/2.5/3.7/4) 5h6/3 7/4 |\nnotes :8 [ t12p7p5h7/4 ] :q 7/5 :8 [ 3s5/5 ]\nnotes :8 5-6-7v/4 (8-9-10/4.11s12/4)v\n\ntabstave notation=true\nnotes :q (8/2.7b9b7/3) (5b6/2.5b6/3)v :8 [ 7s12/4 ]\nnotes [ t:16:9-:8:3s:16:0/4 ]\n\ntabstave notation=true\nnotes :q (5/4.5/5)s(7/4.7/5)s(5/4.5/5)\nnotes :8 [ (5/4.5/5) (7/5) ] |\nnotes :8 [ t(12/5.12/4)s(5/5.5/4) 3b4/5 ] :h 5V/6";
      notEqual(null, tab.parse(code));
      return catchError(tab, "tabstave\n notes :q 5/L");
    };

    VexTab.staveOptionsTest = function() {
      var tab;
      expect(3);
      tab = makeParser();
      notEqual(null, tab.parse("tabstave notation=true key=C#"));
      catchError(tab, "tabstave invalid=true");
      return catchError(tab, "tabstave notation=boo");
    };

    VexTab.notationOnly = function() {
      var clef, clefs, key, tab, time, times, _i, _j, _len, _len1;
      expect(122);
      tab = makeParser();
      notEqual(null, tab.parse("tabstave notation=true"));
      notEqual(null, tab.parse("tabstave\n notes :w 1/2 | 1/3 | 1/5 | 1/4"));
      notEqual(null, tab.parse("tabstave notation=true tablature=false"));
      notEqual(null, tab.parse("tabstave\n notes :w 1/2 | 1/3 | 1/5 | 1/4"));
      catchError(tab, "tabstave notation=false tablature=false");
      clefs = ["treble", "alto", "tenor", "bass"];
      for (_i = 0, _len = clefs.length; _i < _len; _i++) {
        clef = clefs[_i];
        notEqual(null, tab.parse("tabstave notation=true clef=" + clef));
        notEqual(null, tab.parse("tabstave clef=" + clef));
      }
      catchError(tab, "tabstave clef=blah");
      for (key in Vex.Flow.keySignature.keySpecs) {
        notEqual(null, tab.parse("tabstave key=" + key));
        notEqual(null, tab.parse("tabstave notation=true key=" + key));
        notEqual(null, tab.parse("tabstave notation=true tablature=true key=" + key));
      }
      catchError(tab, "tabstave notation=true key=rrr");
      times = ["C", "C|", "2/4", "4/4", "100/4"];
      for (_j = 0, _len1 = times.length; _j < _len1; _j++) {
        time = times[_j];
        notEqual(null, tab.parse("tabstave time=" + time));
        notEqual(null, tab.parse("tabstave notation=true time=" + time));
        notEqual(null, tab.parse("tabstave notation=true tablature=true time=" + time));
      }
      catchError(tab, "tabstave notation=true time=rrr");
      return ok(true, "all pass");
    };

    VexTab.tuning = function() {
      var tab;
      expect(9);
      tab = makeParser();
      notEqual(null, tab.parse("tabstave tuning=E/5,B/4,G/4,D/4,A/3,E/3"));
      notEqual(null, tab.parse("tabstave tuning=standard"));
      notEqual(null, tab.parse("tabstave tuning=eb"));
      notEqual(null, tab.parse("tabstave tuning=dropd"));
      catchError(tab, "tabstave tuning=,B/4,G/4,D/4,A/3,E/3");
      catchError(tab, "tabstave tuning=/4,G/4,D/4,A/3,E/3");
      catchError(tab, "tabstave tuning=E,B,G,D,A,E");
      catchError(tab, "tabstave tuning=T/5,B/4,G/4,D/4,A/3,E/3");
      return ok(true, "all pass");
    };

    VexTab.stringFret = function() {
      var tab;
      expect(5);
      tab = makeParser();
      notEqual(null, tab.parse("tabstave\n notes 10/2 10/3"));
      catchError(tab, "tabstave\n notes /2 10/3");
      catchError(tab, "tabstave\n notes j/2 10/3");
      catchError(tab, "tabstave\n notes 4");
      return ok(true, "all pass");
    };

    VexTab.multiFret = function() {
      var tab;
      expect(4);
      tab = makeParser();
      notEqual(null, tab.parse("tabstave\n notes 10-11/3"));
      notEqual(null, tab.parse("tabstave\n notes 10-11-12-13-15/3 5-4-3-2-1/2"));
      catchError(tab, "tabstave\n notes 10/2-10");
      return catchError(tab, "tabstave\n notes 10-/2");
    };

    VexTab.tie = function() {
      var tab;
      expect(6);
      tab = makeParser();
      notEqual(null, tab.parse("tabstave\n notes 10s11/3"));
      notEqual(null, tab.parse("tabstave\n notes 10s11h12p10/3"));
      notEqual(null, tab.parse("tabstave notation=true key=A\n notes :w 5/5 | T5/5 | T5V/5"));
      catchError(tab, "tabstave\n notes 10/2s10");
      catchError(tab, "tabstave\n notes 10s");
      return ok(true, "all pass");
    };

    VexTab.bar = function() {
      var tab;
      expect(5);
      tab = makeParser();
      notEqual(null, tab.parse("tabstave\n notes |10s11/3"));
      notEqual(null, tab.parse("tabstave\n notes 10s11h12p10/3|"));
      notEqual(null, tab.parse("tabstave notation=true key=A\n notes || :w || 5/5 ||| T5/5 | T5V/5"));
      catchError(tab, "tabstave\n | notes 10/2s10");
      return ok(true, "all pass");
    };

    VexTab.bend = function() {
      var tab;
      expect(5);
      tab = makeParser();
      notEqual(null, tab.parse("tabstave\n notes 10b11/3"));
      notEqual(null, tab.parse("tabstave\n notes 10b11s12/3"));
      notEqual(null, tab.parse("tabstave\n notes 10s11b12/3"));
      catchError(tab, "tabstave\n notes 10b12b10b-/2");
      return ok(true, "all pass");
    };

    VexTab.vibrato = function() {
      var tab;
      expect(10);
      tab = makeParser();
      notEqual(null, tab.parse("tabstave\n notes 10v/3"));
      notEqual(null, tab.parse("tabstave\n notes 10-11v-12v/3"));
      notEqual(null, tab.parse("tabstave\n notes 10b11v-12/3"));
      notEqual(null, tab.parse("tabstave\n notes 10b11b10v-12/3"));
      notEqual(null, tab.parse("tabstave\n notes 10s11v-12/3"));
      notEqual(null, tab.parse("tabstave\n notes 10s11vs4s12vh15p10-1/2"));
      catchError(tab, "tabstave\n notes 10v");
      catchError(tab, "tabstave\n notes 10vb/1");
      catchError(tab, "tabstave\n notes 10-b11/3");
      return ok(true, "all pass");
    };

    VexTab.strokes = function() {
      var tab;
      expect(10);
      tab = makeParser();
      notEqual(null, tab.parse("tabstave\n notes 10d/3"));
      notEqual(null, tab.parse("tabstave\n notes 10-11u-12d/3"));
      notEqual(null, tab.parse("tabstave\n notes 10b11u-12/3"));
      notEqual(null, tab.parse("tabstave\n notes 10b11b10d-12/3"));
      notEqual(null, tab.parse("tabstave\n notes 10s11d-12/3"));
      notEqual(null, tab.parse("tabstave\n notes 10s11us4s12vh15p10-1/2"));
      notEqual(null, tab.parse("tabstave\n notes (10/2.10/1)d"));
      catchError(tab, "tabstave\n notes 10vb/1");
      catchError(tab, "tabstave\n notes 10-b11/3");
      return ok(true, "all pass");
    };

    VexTab.chord = function() {
      var tab;
      expect(8);
      tab = makeParser();
      notEqual(null, tab.parse("tabstave\n notes (4/6)"));
      notEqual(null, tab.parse("tabstave\n notes (4/5.6/6)"));
      catchError(tab, "tabstave\n notes (4/5.6/7)", "BadArguments");
      catchError(tab, "tabstave\n notes (4");
      catchError(tab, "tabstave\n notes (4/)");
      catchError(tab, "tabstave\n notes (/5)");
      catchError(tab, "tabstave\n notes (4/5.)");
      return ok(true, "all pass");
    };

    VexTab.tapping = function() {
      var tab;
      expect(5);
      tab = makeParser();
      notEqual(null, tab.parse("tabstave\n notes t5p4p3/3"));
      notEqual(null, tab.parse("tabstave\n notes 5t12p5-4-3/1"));
      catchError(tab, "tabstave\n notes 5t/4");
      catchError(tab, "tabstave\n notes t-4-4h5/3");
      return ok(true, "all pass");
    };

    VexTab.chordTies = function() {
      var tab;
      expect(7);
      tab = makeParser();
      notEqual(null, tab.parse("tabstave\n notes (1/2.2/3)s(3/2.4/3)"));
      notEqual(null, tab.parse("tabstave\n notes (1/2.2/3.3/4)s(3/2.4/3.5/4)"));
      notEqual(null, tab.parse("tabstave\n notes (4/5.1/2.2/3)s(3/2.4/3)"));
      notEqual(null, tab.parse("tabstave\n notes (1/2.2/3)s(3/2.5/5.4/3)"));
      notEqual(null, tab.parse("tabstave\n notes (1/2.2/3)s(3/2.4/3)h(6/2.7/3)"));
      notEqual(null, tab.parse("tabstave\n notes t(1/2.2/3)s(3/2.4/3)h(6/2.7/3)"));
      return ok(true, "all pass");
    };

    VexTab.duration = function() {
      var tab;
      tab = makeParser();
      notEqual(null, tab.parse("tabstave\n notes :w (1/2.2/3)s(3/2.4/3)"));
      notEqual(null, tab.parse("tabstave\n notes :h (1/2.2/3)s(3/2.4/3) :q 1/2"));
      notEqual(null, tab.parse("tabstave\n notes :h (1/2.2/3)s(3/2.4/3) 1/2 ^3^"));
      catchError(tab, "tabstave notation=true\n notes :w (1/2.2/3)s(3/2.4/3) ^3^", "ArtistError");
      return ok(true, "all pass");
    };

    VexTab.tripletsAndTuplets = function() {
      var code, tab;
      expect(1);
      tab = makeParser();
      code = "tabstave notation=true key=Ab tuning=eb\nnotes :8 5s7s8/5 ^3^ :16 (5/2.6/3) 7-12-15s21/3 ^5^\ntabstave notation=true key=Ab tuning=eb\nnotes :8 5h7s9-12s15p12h15/5 ^7^ | :q 5-7-8/5 ^3^";
      return notEqual(null, tab.parse(code));
    };

    VexTab.dottedNotes = function() {
      var code, tab;
      expect(1);
      tab = makeParser();
      code = "tabstave notation=true time=4/4 key=Ab tuning=eb\nnotes :8d 5/4 :16 5/5 :8d 5/4 :16 5/5 :8d 5/4 :16 5/5 :q 5v/5";
      return notEqual(null, tab.parse(code));
    };

    VexTab.annotations = function() {
      var code, tab;
      expect(1);
      tab = makeParser();
      code = "tabstave notation=true time=4/4 key=Ab tuning=eb\nnotes :q 5/5 5/4 5/3 ^3^ $Fi,Ga,Ro!$ :h 4/4 $Blah!$\n\ntabstave notation=true key=A\nnotes :q (5/2.5/3.7/4) $.big.A7#9$ 5h6/3 7/4 |\nnotes :8 7/4 $.italic.sweep$ 6/3 5/2 3v/1 :q 7v/5 $.Arial-10-bold.P.H$ :8 3s5/5";
      return notEqual(null, tab.parse(code));
    };

    VexTab.longBends = function() {
      var code, tab;
      expect(1);
      tab = makeParser();
      code = "tabstave notation=true key=A\nnotes :8 7b9b7b9b7s12b14b12s7s5s2/3";
      return notEqual(null, tab.parse(code));
    };

    VexTab.rest = function() {
      var code, tab;
      expect(1);
      tab = makeParser();
      code = "tabstave notation=true key=A\nnotes :8 ## 7b9b7b9b7s12b14b12s7s5s2/3 #0# 4/4 #9# 5/5";
      return notEqual(null, tab.parse(code));
    };

    VexTab.options = function() {
      var tab;
      expect(8);
      tab = makeParser();
      notEqual(null, tab.parse("options width=400\ntabstave\n"));
      notEqual(null, tab.parse("options font-face=Arial\ntabstave\n"));
      notEqual(null, tab.parse("options font-size=10\ntabstave\n"));
      notEqual(null, tab.parse("options font-style=italic\ntabstave\n"));
      notEqual(null, tab.parse("options space=40\ntabstave\n"));
      notEqual(null, tab.parse("options stave-distance=40\ntabstave\n"));
      catchError(tab, "options w=40\ntabstave\n notes /2 10/3");
      return ok(true, "all pass");
    };

    VexTab.abcNotes = function() {
      var tab;
      expect(6);
      tab = makeParser();
      notEqual(null, tab.parse("tabstave notation=true\n notes A/5 C-D-E/5"));
      notEqual(null, tab.parse("tabstave\n notes :q A/5 C-D-:h:E/5"));
      notEqual(null, tab.parse("tabstave\n notes :q (A/5.A/4)T(A/5.A/4)"));
      notEqual(null, tab.parse("tabstave notation=true tablature=false\n notes A#/5 C##-D@@-E/5"));
      notEqual(null, tab.parse("tabstave\n notes An/5 C-D@-E/5"));
      return ok(true, "all pass");
    };

    VexTab.abcNotesWithFrets = function() {
      var tab;
      expect(6);
      tab = makeParser();
      notEqual(null, tab.parse("tabstave notation=true\n notes A5_5/5 Cn~4_4-5-6/5"));
      notEqual(null, tab.parse("tabstave\n notes :q A/5 C-D-:h:A4_6/5"));
      notEqual(null, tab.parse("tabstave\n notes :q (E@2_6/5.A/4)T(A/5.A/4)"));
      notEqual(null, tab.parse("tabstave notation=true tablature=false\n notes A#3_4/5 C##-D@@-E/5"));
      notEqual(null, tab.parse("tabstave\n notes A@~3_6/5 C-D@-E/5"));
      return ok(true, "all pass");
    };

    VexTab.rhythmNotation = function() {
      var tab;
      expect(4);
      tab = makeParser();
      notEqual(null, tab.parse("tabstave\n notes :qS A/5 C-D-:h:E/5"));
      notEqual(null, tab.parse("tabstave notation=true\n notes :16S (A/5.A/4)T(A/5.A/4)"));
      notEqual(null, tab.parse("tabstave notation=true tablature=false\n notes :qS X/5 C-D-:h:E/5"));
      return ok(true, "all pass");
    };

    VexTab.textLines = function() {
      var tab;
      expect(6);
      tab = makeParser();
      notEqual(null, tab.parse("tabstave\n notes :qS A/5 C-D-:h:E/5"));
      notEqual(null, tab.parse("tabstave\n text .4, Blah, :16, Boo"));
      notEqual(null, tab.parse("tabstave notation=true\n text .4, Blah, :16, Boo"));
      notEqual(null, tab.parse("tabstave notation=true\n text .4, Blah,++, :16, Boo"));
      notEqual(null, tab.parse("tabstave notation=true\n text .4, .strict, Blah,++, :16, .smooth, Boo"));
      return ok(true, "all pass");
    };

    VexTab.sweepStrokes = function() {
      var tab;
      expect(8);
      tab = makeParser();
      notEqual(null, tab.parse("tabstave\n notes :q (5/2.5/3.7/4) $.stroke/rd.$"));
      notEqual(null, tab.parse("tabstave\n notes :q (5/2.5/3.7/4) $.stroke/ru.$"));
      notEqual(null, tab.parse("tabstave\n notes :q (5/2.5/3.7/4) $.stroke/bu.$"));
      notEqual(null, tab.parse("tabstave\n notes :q (5/2.5/3.7/4) $.stroke/bd.$"));
      notEqual(null, tab.parse("tabstave\n notes :q (5/2.5/3.7/4) $.stroke/qu.$"));
      notEqual(null, tab.parse("tabstave\n notes :q (5/2.5/3.7/4) $.stroke/qd.$"));
      catchError(tab, "tabstave\n notes :q (5/2.5/3.7/4) $.stroke/xd.$", "ArtistError");
      return ok(true, "all pass");
    };

    VexTab.voices = function() {
      var code, tab;
      expect(1);
      tab = makeParser();
      code = "options stave-distance=30\ntabstave notation=true\n         key=A\n         time=4/4\nvoice\n    notes :q (5/2.5/3.7/4) :8 7p5h6/3 ^3^ 5h6h7/5 ^3^ :q 7V/4 |\n    notes :8 t12p7/4 s5s3/4 :8 3s:16:5-7/5 :q p5/4\nvoice\n    notes :h 5/6 :q 5/6 :8 4-5/5 | :w 5/5";
      return notEqual(null, tab.parse(code));
    };

    VexTab.fingering = function() {
      var tab;
      expect(7);
      tab = makeParser();
      notEqual(null, tab.parse("tabstave\n notes :q (5/2.5/3.7/4) $.fingering/0:r:s:1.$"));
      notEqual(null, tab.parse("tabstave\n notes :q (5/2.5/3.7/4) $.fingering/0:l:f:1.$"));
      notEqual(null, tab.parse("tabstave\n notes :q (5/2.5/3.7/4) $.fingering/0:a:s:1.$"));
      notEqual(null, tab.parse("tabstave\n notes :q (5/2.5/3.7/4) $.fingering/0:b:s:1.$"));
      notEqual(null, tab.parse("tabstave\n notes :q (5/2.5/3.7/4) $.fingering/0:l:f:1.$"));
      notEqual(null, tab.parse("tabstave\n notes :q (5/2.5/3.7/4) $.fingering/0:r:s:1.$"));
      return ok(true, "all pass");
    };

    VexTab.render = function() {
      var renderer, tab;
      tab = makeParser();
      renderer = makeRenderer("Render");
      notEqual(null, tab.parse("tabstave\n notes :q (5/2.5/3.7/4) $.fingering/0:r:s:1.$"));
      tab.getArtist().render(renderer);
      return ok(true, "all pass");
    };

    VexTab.renderComplex = function() {
      var code;
      code = "options space=20 tab-stems=true stave-distance=40 tab-stem-direction=down\ntabstave notation=true key=A time=4/4\n    notes :q =|: (5/2.5/3.7/4) :8 7-5h6/3 ^3^ 5h6-7/5 ^3^ :q 7V/4 |\n    notes :8 t12p7/4 s5s3/4 :8 3s:16:5-7/5 :h p5/4\n    text :w, |#segno, ,|, :hd, , #tr\n\noptions space=65\ntabstave notation=true\n    notes :q (5/4.5/5) (7/4.7/5)s(5/4.5/5) ^3^\n    notes :8 7-5/4 $.a./b.$ (5/4.5/5)h(7/5) =:|\n    notes :8 (12/5.12/4)ds(5/5.5/4)u 3b4/5\n    notes :h (5V/6.5/4.6/3.7/2) $.italic.let ring$ =|=\n    text :h, ,.font=Times-12-italic, D.S. al coda, |#coda\n    text :h, ,.-1, .font=Arial-14-bold,A13\n    text ++, .30, #f\n\noptions space=70";
      return renderTest("Render Complex", code);
    };

    VexTab.tabStems = function() {
      var code;
      code = "options tab-stems=true\ntabstave key=A\nnotes :q (5/2.5/3.7/4) $.a./b.$ :8 5h6/3 7/4 $.a>/b.$\nnotes :16 5h6/3 7/4 $.a>/b.$\nnotes :8d 5/5";
      renderTest("Tab Stems", code);
      code = "options tab-stems=true tab-stem-direction=down\ntabstave key=A notation=true\nnotes :q (5/2.5/3.7/4) $.a./b.$ :8 5h6/3 7/4 $.a>/b.$\nnotes :16 5h6/3 7/4 $.a>/b.$\nnotes :8d 5/5";
      return renderTest("Tab Stem Direction", code);
    };

    VexTab.restsInTab = function() {
      var code;
      code = "options tab-stems=true\ntabstave key=A\nnotes :q (5/2.5/3.7/4) $.a./b.$ :8 5h6/3 7/4 $.a>/b.$\nnotes :16 5h6/3 7/4 $.a>/b.$\nnotes :8d ##";
      return renderTest("Rests in Tab", code);
    };

    VexTab.timeSigBeaming = function() {
      var code;
      code = "tabstave notation=true tablature=false time=4/4\nnotes :8 ## D-E-F-G-A-B/4 C/5\n\ntabstave notation=true tablature=false time=6/8\nnotes :8 C-D-E-F/4 ## A-B/4 C-D-E-F-:16:G-F/5";
      return renderTest("Time Signature based Beaming", code);
    };

    VexTab.multiStringTab = function() {
      var code;
      code = "tabstave key=A strings=4\nnotes :q (5/2.5/3.7/4) $.a./b.$ :8 5h6/3 7/4 $.a>/b.$\nnotes :16 5h6/3 7/4 $.a>/b.$\noptions space=20";
      renderTest("Bass Tab", code);
      code = "tabstave key=A strings=8 tuning=E/5,B/4,G/4,D/4,A/3,E/3,B/2,G/2\nnotes :q (5/2.5/3.7/8) :8 5h6/3 7/8\nnotes :16 5h6/3 7/7";
      return renderTest("8-string Tab", code);
    };

    VexTab.overrideFretNote = function() {
      var code;
      code = "options stave-distance=30 space=20\noptions font-face=courier font-style=bold\ntabstave notation=true key=A time=5/4\nnotes :q 8/4 $8/4$\nnotes B@4_8/4 $B@4_8/4$\nnotes B@~4_8/4 $B@~4_8/4$\nnotes C@@5_8/4 $C@@5_8/4$\nnotes G##5_5/1 $G##5_5/1$\ntext .font=Times-15-italic,|8va";
      return renderTest("Override Fret Note", code);
    };

    VexTab.mixedTuplets = function() {
      var code;
      code = "tabstave notation=true tablature=false key=G time=4/4\nnotes :q E/5 :8 E/5 ^3,2^ :8 E/5 :q E/5 ^3,2^\nnotes :8 E-E-E/5 ^3^ ## E-E/5 ^3^\n\noptions space=20";
      return renderTest("Mixed Tuplets", code);
    };

    VexTab.accidentalStrategies = function() {
      var code;
      code = "options player=true tempo=80\ntabstave notation=true key=G time=4/4\nnotes :8 5-5-6-6-5-5-3-3/3";
      renderTest("Standard Accidental Strategy", code);
      code = "options player=true tempo=80 accidentals=cautionary\ntabstave notation=true key=G time=4/4\nnotes :8 5-5-6-6-5-5-3-3/3";
      return renderTest("Cautionary Accidental Strategy", code);
    };

    VexTab.fingeringAndStrings = function() {
      var code;
      code = "options space=40 player=true tempo=80 instrument=acoustic_guitar_nylon\ntabstave notation=true tablature=false key=G time=4/4\nvoice\n    notes !octave-shift -1!\n    notes :8 ## (D/4.G/4.D/5.G/5)\n    notes $.fingering/4:r:f:4-3:r:f:3.$\n    notes $.fingering/4:l:s:1-3:r:s:2.$\n\n    notes :h (E/4.G/4.C/5.E/5)\n    notes $.fingering/1:r:f:2-3:r:f:1.$\n    notes $.fingering/1:l:s:4-3:r:s:2.$\n    notes :q ##\nvoice\n    notes :8 G/3 $.fingering/1:r:f:2-1:r:s:6.$\n    notes :8 F/3 $.fingering/1:r:f:1-1:r:s:6.$\n    notes :q G/3 $.fingering/1:r:f:2-1:r:s:6.$\n    notes :q G/3 $.fingering/1:r:f:2-1:r:s:6.$\n    notes :q G/3 $.fingering/1:r:f:2-1:r:s:6.$\n\ntext .font=Arial-14-Bold,.-2\ntext :8,G,G/F,:h,Am/G\n\noptions space=60";
      return renderTest("Fret Hand Fingering and String Numbers", code);
    };

    return VexTab;

  })();

}).call(this);
